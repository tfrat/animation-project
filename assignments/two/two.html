<html>
<head>
	<title>Assignment Two: Dynamics</title>
	<style>
	body { margin: 0; }
	canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
	<input type="file" id="fileLoader" style="display:none;" />
	<script src="../../js/three.min.js"></script>
	<script src="../../js/dat.gui.min.js"></script>
	<script src="../../js/animator.js"></script>
	<script src="../../js/physics.js"></script>
	<script>
	var scene = new THREE.Scene()
	var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )

	// Initialize the renderer
	var renderer = new THREE.WebGLRenderer( { antialias: true })
	renderer.setSize( window.innerWidth, window.innerHeight )
	renderer.shadowMap.enabled = true
	renderer.shadowMap.type = THREE.PCFShadowMap

	// Add the WebGL canvas to browser's window
	var canvas = renderer.domElement
	document.body.appendChild( canvas )

	window.addEventListener( 'resize', onWindowResize, false )
	// Update the canvas and camera when the browser window size is modified
	function onWindowResize(){
		camera.aspect = window.innerWidth / window.innerHeight
		camera.updateProjectionMatrix()

		renderer.setSize( window.innerWidth, window.innerHeight )
	}

	// A cone of light placed directly over the pool table
	var spotLight = new THREE.SpotLight( 0xffffff )
	spotLight.position.set( 0, 100, 0 )

	spotLight.castShadow = true

	spotLight.shadowMapWidth = 1024
	spotLight.shadowMapHeight = 1024

	spotLight.shadowCameraNear = 10
	spotLight.shadowCameraFar = 200
	spotLight.shadowCameraFov = 40

	scene.add( spotLight );

	// Adds a soft white light everywhere in the scene
	var light = new THREE.AmbientLight( 0x404040 );
	scene.add( light );

	// Generate the scene

	/* Sphere */
	var sphereGeometry = new THREE.SphereGeometry( .187, 32, 32 )
	var cueBallTexture = new THREE.ImageUtils.loadTexture('../../textures/balls/BallCue.jpg')
	cueBallTexture.minFilter = THREE.LinearFilter
	var cueBallMaterial = new THREE.MeshPhongMaterial( {
		map: cueBallTexture,
		specular: 0x222222,
		shininess: 100,
		shading: THREE.SmoothShading
	} )

	var cueBall = new THREE.Mesh( sphereGeometry, cueBallMaterial )
	cueBall.castShadow = true
	cueBall.receieveShadow = true

	var oneBallTexture = new THREE.ImageUtils.loadTexture('../../textures/balls/Ball1.jpg')
	oneBallTexture.minFilter = THREE.LinearFilter
	var oneBallMaterial = new THREE.MeshPhongMaterial( {
		map: oneBallTexture,
		specular: 0x222222,
		shininess: 100,
		shading: THREE.SmoothShading
	} )

	var oneBall = new THREE.Mesh( sphereGeometry, oneBallMaterial )
	oneBall.castShadow = true
	oneBall.receieveShadow = true

	var twoBallTexture = new THREE.ImageUtils.loadTexture('../../textures/balls/Ball2.jpg')
	twoBallTexture.minFilter = THREE.LinearFilter
	var twoBallMaterial = new THREE.MeshPhongMaterial( {
		map: twoBallTexture,
		specular: 0x222222,
		shininess: 100,
		shading: THREE.SmoothShading
	} )

	var twoBall = new THREE.Mesh( sphereGeometry, twoBallMaterial )
	twoBall.castShadow = true
	twoBall.receieveShadow = true

	//console.log("Sphere radius: " + sphere.geometry.parameters.radius)

	/* Table */
	var tableGeometry = new THREE.PlaneBufferGeometry(8, 4)
	var tableTexture = THREE.ImageUtils.loadTexture('../../textures/pool_table.png')
	tableTexture.wrapS = tableTexture.wrapT = THREE.RepeatWrapping
	tableTexture.repeat.set(16, 16)

	var tableMaterial = new THREE.MeshLambertMaterial( { map: tableTexture } )
	var table = new THREE.Mesh( tableGeometry, tableMaterial)
	table.material.side = THREE.DoubleSide
	table.receiveShadow = true
	table.castShadow = false

	/* Cushions */
	var shortCushionGeometry = new THREE.BoxGeometry( 4.5, .33, .25 )
	var shortCushionTexture = THREE.ImageUtils.loadTexture('../../textures/pool_cushion.png')
	shortCushionTexture.wrapS = tableTexture.wrapT = THREE.MirroredRepeatWrapping
	shortCushionTexture.repeat.set(16, 1)
	shortCushionTexture.minFilter = THREE.NearestFilter

	var longCushionGeometry = new THREE.BoxGeometry( 8, .33, .25)
	var longCushionTexture = THREE.ImageUtils.loadTexture('../../textures/pool_cushion.png')
	longCushionTexture.repeat.set(32, 1)
	longCushionTexture.wrapS = tableTexture.wrapT = THREE.MirroredRepeatWrapping
	longCushionTexture.minFilter = THREE.NearestFilter

	var shortCushionMaterial = new THREE.MeshPhongMaterial( {
		map: shortCushionTexture,
		specular: 0x222222,
		shininess: 30,
		shading: THREE.SmoothShading } )
	var longCushionMaterial = new THREE.MeshPhongMaterial( {
		map: longCushionTexture,
		specular: 0x222222,
		shininess: 30,
		shading: THREE.SmoothShading } )
	var leftCushion = new THREE.Mesh( longCushionGeometry, longCushionMaterial.clone() )
	leftCushion.receiveShadow = true
	leftCushion.castShadow =  false

	var rightCushion = new THREE.Mesh( longCushionGeometry, longCushionMaterial.clone() )
	rightCushion.receiveShadow = true
	rightCushion.castShadow = false

	var topCushion = new THREE.Mesh( shortCushionGeometry, shortCushionMaterial.clone() )
	topCushion.receiveShadow = true
	topCushion.castShadow = false
	var bottomCushion = new THREE.Mesh( shortCushionGeometry, shortCushionMaterial.clone() )
	bottomCushion.receiveShadow = true
	bottomCushion.castShadow = false

	// Add the objects to the scene
	scene.add( cueBall )
	scene.add( oneBall )
	scene.add( twoBall )
	scene.add( table )
	scene.add( leftCushion )
	scene.add( rightCushion )
	scene.add( topCushion )
	scene.add( bottomCushion )

	// Initialize the object's spatial properties
	cueBall.position.set(0, .187, 0)
	oneBall.position.set(0, .187, 2)
	twoBall.position.set(0, .187, -2)

	table.rotation.set(THREE.Math.degToRad(90), 0, THREE.Math.degToRad(90))

	leftCushion.rotation.set(0, THREE.Math.degToRad(90), 0 )
	leftCushion.position.set(-2.125, .165, 0)

	rightCushion.position.set(2.125, .165, 0)
	rightCushion.rotation.set(0, THREE.Math.degToRad(90), 0 )

	topCushion.position.set(0, .165, 4.125)

	bottomCushion.position.set(0, .165, -4.125)

	// Initialize the camera position
	camera.position.x = 1;
	camera.position.y = 2;
	camera.position.z = 3;

	camera.lookAt( new THREE.Vector3( 0, 0, 0 ))

	var balls = []

	balls.push(new PhysicsObject(cueBall, new THREE.Vector3(0, 0, 5), 1, 10))
	balls.push(new PhysicsObject(oneBall, new THREE.Vector3(0, 0, 0), 1, 1))
	balls.push(new PhysicsObject(twoBall, new THREE.Vector3(0, 0, 0), 1, 1))

	function detectCollisions() {
		for (x in balls) {
			if (x > 0) {
				if (balls[0].object.position.distanceTo(balls[x].object.position) <= .187 + .187) {
					balls[0].tVelocity.multiplyScalar(-1)
				}
			}
		}
	}


	// Rotate the ball slowly
	var animation = function (t) {
		//cueBall.rotation.y = THREE.Math.degToRad(t * 18)

		// Collision detection
		detectCollisions()

		// Force application
		balls[0].applyForces(t)
	}

	animate(scene, renderer, -1, animation)

	/* Holds the properties of the object */
	var ObjectProperties = function() {
	  this.x = 0;
		this.y = 0;
		this.z = 0;
		this.lookAtX = 0;
		this.lookAtY = 0;
		this.lookAtZ = 0;
	  this.velocity = 1;
	};

	window.onload = function() {
		var gui = new dat.GUI();
		var text = new ObjectProperties();

		// Handles the spatial values of the object
		var posFolder = gui.addFolder('Position');
		var posX = posFolder.add(text, 'x', -10, 10);
		var posY = posFolder.add(text, 'y', -10, 10);
		var posZ = posFolder.add(text, 'z', -10, 10);
		var lookAtFolder = gui.addFolder('Look At')
		var lookX = lookAtFolder.add(text, 'lookAtX', -10, 10);
		var lookY = lookAtFolder.add(text, 'lookAtY', -10, 10);
		var lookZ = lookAtFolder.add(text, 'lookAtZ', -10, 10);
	  var velocity = gui.add(text, 'velocity', 0, 50);

		// Listen for values changes and update the object's properties
		posX.onChange(function(value) {
			camera.position.x = value
		})

		posY.onChange(function(value) {
			camera.position.y = value
		})

		posZ.onChange(function(value) {
			camera.position.z = value
		})

		lookX.onChange(function(value) {
			camera.lookAt( new THREE.Vector3(value, text.lookAtY, text.lookAtZ))
		})

		lookY.onChange(function(value) {
			camera.lookAt( new THREE.Vector3(text.lookAtX, value, text.lookAtZ))
		})

		lookZ.onChange(function(value) {
			camera.lookAt( new THREE.Vector3(text.lookAtX, text.lookAtY, value))
		})

		velocity.onChange(function(value) {
			balls[0].tVelocity.multiplyScalar(value)
		})

	};

	</script>
</body>
</html>
