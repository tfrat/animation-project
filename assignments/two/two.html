<html>
<head>
	<title>Assignment Two: Dynamics</title>
	<style>
	body { margin: 0; }
	canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
	<input type="file" id="fileLoader" style="display:none;" />
	<script src="../../js/three.min.js"></script>
	<script src="../../js/dat.gui.min.js"></script>
	<script src="../../js/animator.js"></script>
	<script src="../../js/physics.js"></script>
	<script>
	var scene = new THREE.Scene()
	var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )

	// Initialize the renderer
	var renderer = new THREE.WebGLRenderer( { antialias: true })
	renderer.setSize( window.innerWidth, window.innerHeight )
	renderer.shadowMap.enabled = true
	renderer.shadowMap.type = THREE.PCFShadowMap

	// Add the WebGL canvas to browser's window
	var canvas = renderer.domElement
	document.body.appendChild( canvas )

	window.addEventListener( 'resize', onWindowResize, false )
	// Update the canvas and camera when the browser window size is modified
	function onWindowResize(){
		camera.aspect = window.innerWidth / window.innerHeight
		camera.updateProjectionMatrix()

		renderer.setSize( window.innerWidth, window.innerHeight )
	}

	// A cone of light placed directly over the pool table
	var spotLight = new THREE.SpotLight( 0xffffff )
	spotLight.position.set( 0, 100, 0 )

	spotLight.castShadow = true

	spotLight.shadowMapWidth = 1024
	spotLight.shadowMapHeight = 1024

	spotLight.shadowCameraNear = 10
	spotLight.shadowCameraFar = 200
	spotLight.shadowCameraFov = 40

	scene.add( spotLight );

	// Adds a soft white light everywhere in the scene
	var light = new THREE.AmbientLight( 0x404040 );
	scene.add( light );

	// Generate the scene

	/* Sphere */
	var sphereGeometry = new THREE.SphereGeometry( .187, 32, 32 )
	var cueBallTexture = new THREE.ImageUtils.loadTexture('../../textures/balls/BallCue.jpg')
	cueBallTexture.minFilter = THREE.LinearFilter
	var cueBallMaterial = new THREE.MeshPhongMaterial( {
		map: cueBallTexture,
		specular: 0x222222,
		shininess: 100,
		shading: THREE.SmoothShading
	} )

	var cueBall = new THREE.Mesh( sphereGeometry, cueBallMaterial )
	cueBall.castShadow = true
	cueBall.receieveShadow = true

	var oneBallTexture = new THREE.ImageUtils.loadTexture('../../textures/balls/Ball1.jpg')
	oneBallTexture.minFilter = THREE.LinearFilter
	var oneBallMaterial = new THREE.MeshPhongMaterial( {
		map: oneBallTexture,
		specular: 0x222222,
		shininess: 100,
		shading: THREE.SmoothShading
	} )

	var oneBall = new THREE.Mesh( sphereGeometry, oneBallMaterial )
	oneBall.castShadow = true
	oneBall.receieveShadow = true

	var twoBallTexture = new THREE.ImageUtils.loadTexture('../../textures/balls/Ball2.jpg')
	twoBallTexture.minFilter = THREE.LinearFilter
	var twoBallMaterial = new THREE.MeshPhongMaterial( {
		map: twoBallTexture,
		specular: 0x222222,
		shininess: 100,
		shading: THREE.SmoothShading
	} )

	var twoBall = new THREE.Mesh( sphereGeometry, twoBallMaterial )
	twoBall.castShadow = true
	twoBall.receieveShadow = true

	//console.log("Sphere radius: " + sphere.geometry.parameters.radius)

	/* Table */
	var tableGeometry = new THREE.PlaneBufferGeometry(8, 4)
	var tableTexture = THREE.ImageUtils.loadTexture('../../textures/pool_table.png')
	tableTexture.wrapS = tableTexture.wrapT = THREE.RepeatWrapping
	tableTexture.repeat.set(16, 16)

	var tableMaterial = new THREE.MeshLambertMaterial( { map: tableTexture } )
	var table = new THREE.Mesh( tableGeometry, tableMaterial)
	table.material.side = THREE.DoubleSide
	table.receiveShadow = true
	table.castShadow = false

	/* Cushions */
	var shortCushionGeometry = new THREE.BoxGeometry( 4.5, .33, .25 )
	var shortCushionTexture = THREE.ImageUtils.loadTexture('../../textures/pool_cushion.png')
	shortCushionTexture.wrapS = tableTexture.wrapT = THREE.MirroredRepeatWrapping
	shortCushionTexture.repeat.set(16, 1)
	shortCushionTexture.minFilter = THREE.NearestFilter

	var longCushionGeometry = new THREE.BoxGeometry( 8, .33, .25)
	var longCushionTexture = THREE.ImageUtils.loadTexture('../../textures/pool_cushion.png')
	longCushionTexture.repeat.set(32, 1)
	longCushionTexture.wrapS = tableTexture.wrapT = THREE.MirroredRepeatWrapping
	longCushionTexture.minFilter = THREE.NearestFilter

	var shortCushionMaterial = new THREE.MeshPhongMaterial( {
		map: shortCushionTexture,
		specular: 0x222222,
		shininess: 30,
		shading: THREE.SmoothShading } )
	var longCushionMaterial = new THREE.MeshPhongMaterial( {
		map: longCushionTexture,
		specular: 0x222222,
		shininess: 30,
		shading: THREE.SmoothShading } )
	var leftCushion = new THREE.Mesh( longCushionGeometry, longCushionMaterial.clone() )
	leftCushion.receiveShadow = true
	leftCushion.castShadow =  false

	var rightCushion = new THREE.Mesh( longCushionGeometry, longCushionMaterial.clone() )
	rightCushion.receiveShadow = true
	rightCushion.castShadow = false

	var topCushion = new THREE.Mesh( shortCushionGeometry, shortCushionMaterial.clone() )
	topCushion.receiveShadow = true
	topCushion.castShadow = false
	var bottomCushion = new THREE.Mesh( shortCushionGeometry, shortCushionMaterial.clone() )
	bottomCushion.receiveShadow = true
	bottomCushion.castShadow = false

	// Add the objects to the scene
	scene.add( cueBall )
	scene.add( oneBall )
	scene.add( twoBall )
	scene.add( table )
	scene.add( leftCushion )
	scene.add( rightCushion )
	scene.add( topCushion )
	scene.add( bottomCushion )

	// Initialize the object's spatial properties
	cueBall.position.set(0, .187, 0)
	oneBall.position.set(0, .187, 2)
	twoBall.position.set(0, .187, -2)

	table.rotation.set(THREE.Math.degToRad(90), 0, THREE.Math.degToRad(90))

	leftCushion.rotation.set(0, THREE.Math.degToRad(90), 0 )
	leftCushion.position.set(-2.125, .165, 0)

	rightCushion.position.set(2.125, .165, 0)
	rightCushion.rotation.set(0, THREE.Math.degToRad(90), 0 )

	topCushion.position.set(0, .165, 4.125)

	bottomCushion.position.set(0, .165, -4.125)

	// Initialize the camera position
	camera.position.x = 1;
	camera.position.y = 2;
	camera.position.z = 3;

	camera.lookAt( new THREE.Vector3( 0, 0, 0 ))

	var balls = []

	balls.push(new PhysicsObject(cueBall,
															 1,
															 new THREE.Vector3(0, 0, 0),
															 new THREE.Vector3(0, 0, .1)))
	balls.push(new PhysicsObject(oneBall,
															 1,
															 new THREE.Vector3(0, 0, 0),
															 new THREE.Vector3(0, 0, 0)))
	balls.push(new PhysicsObject(twoBall,
															 1,
															 new THREE.Vector3(0, 0, 0),
															 new THREE.Vector3(0, 0, 0)))

	function detectCollisions() {
		for (x in balls) {
			if (x > 0) {
				if (balls[0].object.position.distanceTo(balls[x].object.position) <= .374) {
					balls[0].acceleration.multiplyScalar(-1)
				}
			}
		}
	}


	// Rotate the ball slowly
	var animation = function (t) {
		//cueBall.rotation.y = THREE.Math.degToRad(t * 18)

		// Collision detection
		detectCollisions()

		// Force application
		balls[0].updateForces(t)
		balls[0].applyForces(t)
	}

	animate(scene, renderer, -1, animation)

	/* Holds the properties of the object */
	var ObjectProperties = function() {
	  this.x = 0;
		this.y = 0;
		this.z = 0;
	  this.mass = 1;
	};

	window.onload = function() {
		var gui = new dat.GUI();
		var text = new ObjectProperties();

		// Handles the spatial values of the object
		var posFolder = gui.addFolder('Acceleration');
		var accX = posFolder.add(text, 'x', -2, 2).step(.25);
		var accY = posFolder.add(text, 'y', -2, 2);
		var accZ = posFolder.add(text, 'z', -2, 2);
	  var mass = gui.add(text, 'mass', 1, 10);

		// Listen for values changes and update the object's properties
		accX.onChange(function(value) {
			balls[0].acceleration.x = value
		})

		accY.onChange(function(value) {
			balls[0].acceleration.y = value
		})

		accZ.onChange(function(value) {
			balls[0].acceleration.z = value
		})

		mass.onChange(function(value) {
			balls[0].mass = value
		})

	};

	</script>
</body>
</html>
