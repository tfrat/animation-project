<html>
<head>
	<title>Particle System</title>
	<style>
	body { margin: 0; }
	canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
	<input type="file" id="fileLoader" style="display:none;" />
	<script src="../../js/three.min.js"></script>
	<script src="animator.js"></script>
	<script src="particle.js"></script>
	<script src="worker.js"></script>
	<script>

	var keyframe = null;
	var currentFrame = null;
	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

	var renderer = new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );

	// Add the WebGL canvas to browser's window
	var canvas = renderer.domElement
	document.body.appendChild( canvas );

	window.addEventListener( 'resize', onWindowResize, false )
	// Update the canvas and camera when the browser window size is modified
	function onWindowResize(){
		camera.aspect = window.innerWidth / window.innerHeight
		camera.updateProjectionMatrix()

		renderer.setSize( window.innerWidth, window.innerHeight )
	}

	var leader = makeParticle(.1, 0xffffff)
	scene.add( leader );

	function randomRange(start, end) {
		return (Math.random() * (end - start)) + start
	}


	var workerListener = function(e) {
		var id = e.data.id
		var cmd = e.data.cmd
		switch(cmd) {
			case 'message':
			console.log('Worker #' + id + ": " + e.data.msg)
			break
			case 'update':
			var pos = e.data.pos
			tail[id].position.x = pos.x
			tail[id].position.y = pos.y
			tail[id].position.z = pos.z
			break
			case 'terminate':
			scene.remove(tail[id])
			break


		}
	}

	var tail = {}

	for (var i = 0; i < 10; i++) {
		tail[i] = makeParticle(.01, 0x0000ff)
		tail[i].position.x = randomRange(-1, 1)
		tail[i].position.y = randomRange(-1, 1)
		scene.add( tail[i] )

		var worker = new Worker('worker.js')

		worker.addEventListener('message', workerListener )

		var velo = new THREE.Vector3(randomRange(-1, 1), randomRange(-1, 1), 0)

		worker.postMessage({'id' : i,
		'pos' : { 'x' : tail[i].position.x, 'y' : tail[i].position.y, 'z' : tail[i].position.z },
		'vel' : { 'x' : velo.x, 'y' : velo.y, 'z' : velo.z }})
	}

	camera.position.z = 5;

	// Used to load files from the file chooser.
	var fileLoader = document.getElementById("fileLoader")
	fileLoader.addEventListener("change", getInputFile, false)

	// Allows the user to use the file chooser instead of clicking.
	canvas.addEventListener("click", function () {
		console.log("Clicked")
		fileLoader.click()
	});

	// To enable drag and drop
	canvas.addEventListener("dragover", function (evt) {
		evt.preventDefault();
	}, false);

	// Loads the file and creates the Keyframes list
	canvas.addEventListener("drop", getDropFile, false);

	// Gets the file from a drop event.
	function getDropFile(evt) {
		evt.preventDefault();
		loadKeyframes(evt.dataTransfer.files[0])
	}

	// Get the file from a click.
	function getInputFile(evt) {
		evt.preventDefault();
		loadKeyframes(fileLoader.value)
	}
	/*
	var animation = function (t) {
	// If the time is past the current keyframe then slide to the next pair
	if(currentFrame.peek().t <= t) {
	currentFrame = currentFrame.peek()
	console.log("===================== Keyframe Swap: " + t)
}

// Create a new middle frame with interpolation
var newFrame = currentFrame.interpolate(currentFrame.peek(), t - currentFrame.t)

// Set the new position
leader.position.setX(newFrame.position.x)
leader.position.setY(newFrame.position.y)
leader.position.setZ(newFrame.position.z)
}
*/
var animation = function (t) {
	return true
}

animate(scene, renderer, animation)


</script>
</body>
</html>
